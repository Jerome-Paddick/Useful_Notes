FLASK

//////// CVAPI ////////

source VirtualEnvs/cvapi/bin/activate


//////// GENERAL ////////

Flask Templates
"Ginger" Framework

All Flask apps create an "Application Instance" -> an object to which all requests are sent for handling using WSGI (Web Server Gateway Interface) protocol

WSGI -> server/gateway side, and application/framework side, WSGI middle-ware
	WSGI middleware python callable that is converted into a generator

Generator -> Function that behaves like an iterator (can be iterated upon)

Only requirement for Flask class creator is name of module or package, for most instances it is pythons __name__ variable, used to determine root path of the application
 -> flask = app(__name__)


//////// ROUTES AND VIEWS ////////

client request -> web server -> Flask application Instance -> handled and passed to handler function
FAI Response -> client

FAI keeps a mapping of URLs to python functions, mostly through @app.route("/") decorator
decorator adjust the behaviour of a function
decorator can register functions as handlers for an event

@app.route("/")
def index():
	return "<h1> HEllo <h1>"

the @app.route decorator registers the index() function as the handler for the root url, the return of the function is the response

index() -> VIEW Function

variables can be used in the route decorator -> 
@app.route("/<name>")
def index(name):
	return "<h1> Hello %s <h1>" %name

Types
eg. @app.route("/<int:id>")  will only match URLs with int
int, float, path (string with slashes)


//////// SERVER-STARTUP ////////

FAI instance has a run method to launch server
if __name__ == "__main__":
	app.run(debug=True)

the __name__ == "__main__" syntax ensures code only runs when code is called directly (instead of eg. file import)

server loops and acts as a listener for requests
debug -> activated debugger and reloader

//////// REQUEST-RESPONSE Context ////////


FIA recieves request -> makes objects available for handlers
request object -> encapsulates request object HTTP request from client

Instead of passing these objects to every possible handler as arguments
Flask CONTEXTS can make an object GLOBALLY available to a THREAD without making it available to other threads

from flask import request
@app.route("/")
def index():
	user_agent = request.headers.get("User-Agent")  # 
	return "<p>Your Browser is %s<p>" % user_agent

request is used as if it was a global variable, which is impossible as a multithreaded server is running multiple requests simultaneously.

A thread is the smallest sequence of instructions that can be managed independantly 
--> multithreaded servers start a pool of threads and select a thread from the pool for each incoming request

CONTEXTS -> 2 contexts 
1. Apllication Context
	current_app -> 	Application Instance
	g -> 		object that the application uses for temporary storage
2. Request Context
	request ->	HTTP request object sent by client
	session -> 	user session dictionary
			can be used to store values that are "remembered" between requests

Flask activates (or pushes) the application and request contexts before dispatching a request and then removes them when the requedst is handled

When application context is pushed
-> current_app & g made available to thread
when request context is pushed
-> request & session made available to thread

PUSHING A CONTEXT:

from hello import app
from flask import current_app

# calling current_app.name  at this point will fail as it outside app instance

app_ctx = app.app_context()
app_ctx.push()
current_app.name
>> "Hello"

//////// REQUEST DISPATCHING ////////



